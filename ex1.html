<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Immersive Digital Fabric</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevents scrollbars */
            background-color: #232528;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #input_video {
            display: none; /* Hide webcam feed */
        }
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            pointer-events: none;
            text-align: center;
        }
        #loading {
            color: #444bd3;
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="loading">Initializing Neural Grid...</div>
    </div>
    <video id="input_video"></video>
    <div id="canvas-container"></div>

<script>
    // --- CONFIGURATION ---
    const CONFIG = {
        segmentsX: 70,         // Higher res for smoother waves
        segmentsY: 20,
        color: 0x00ffff,        // Cyan
        cameraZ: 30,            // Camera distance
        brushRadius: 8.0,       // Interaction radius
        brushStrength: 1.1,     // Interaction height
        decay: 0.99,            // How fast bumps sink (0.90 - 0.99)
        waveSpeed: 1.2,
        waveHeight: 0.7
    };

    // --- GLOBALS ---
    let scene, camera, renderer, mesh;
    let elevationData = [];
    let worldWidth, worldHeight;
    let fingerPos = { x: 0, y: 0, active: false };

    // --- 1. SCENE SETUP ---
    function initThree() {
        const container = document.getElementById('canvas-container');

        scene = new THREE.Scene();
        // Set scene background to black to match body
        scene.background = new THREE.Color(0x000000); 

        // Camera setup
        const fov = 45;
        camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, CONFIG.cameraZ); 
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimize performance
        container.appendChild(renderer.domElement);

        // Calculate Visible Size at z=0 to fill screen
        // Formula: height = 2 * tan(fov/2) * distance
        const vFOV = (camera.fov * Math.PI) / 180;
        const visibleHeight = 2 * Math.tan(vFOV / 2) * CONFIG.cameraZ;
        const visibleWidth = visibleHeight * camera.aspect;

        // Make geometry 1.2x larger than visible area to ensure no borders ever appear
        worldWidth = visibleWidth * 1.2; 
        worldHeight = visibleHeight * 1.2;

        const geometry = new THREE.PlaneGeometry(worldWidth, worldHeight, CONFIG.segmentsX, CONFIG.segmentsY);

        // Initialize elevation buffer
        const vertexCount = geometry.attributes.position.count;
        elevationData = new Float32Array(vertexCount).fill(0);

        // Material
        const material = new THREE.MeshBasicMaterial({
            color: CONFIG.color,
            wireframe: true,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide
        });

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Resize Listener
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Recalculate dimensions to keep mesh filling screen if aspect changes drastically
        const vFOV = (camera.fov * Math.PI) / 180;
        const visibleHeight = 2 * Math.tan(vFOV / 2) * CONFIG.cameraZ;
        const visibleWidth = visibleHeight * camera.aspect;
        
        // Scale mesh to fit new aspect ratio
        // Note: Real-time geometry reconstruction is heavy, so we scale existing mesh
        // This might stretch the grid slightly, but keeps it full-screen.
        const targetScaleX = (visibleWidth * 1.2) / worldWidth;
        const targetScaleY = (visibleHeight * 1.2) / worldHeight;
        
        mesh.scale.set(targetScaleX, targetScaleY, 1);
    }

    // --- 2. MEDIAPIPE LOGIC ---
    function onResults(results) {
        const loading = document.getElementById('loading');
        if (loading) loading.style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const indexTip = landmarks[8]; // Index finger tip

            // Map 0..1 to World Coordinates based on actual Mesh Size
            // mesh.scale.x accounts for window resizing
            const currentWidth = worldWidth * mesh.scale.x;
            const currentHeight = worldHeight * mesh.scale.y;

            // X is inverted in MediaPipe relative to screen space usually
            const x = (1 - indexTip.x) * currentWidth - (currentWidth / 2);
            // Y is inverted (0 is top in MP, but +Y is top in 3D)
            const y = (1 - indexTip.y) * currentHeight - (currentHeight / 2);

            fingerPos.x = x;
            fingerPos.y = y;
            fingerPos.active = true;
        } else {
            fingerPos.active = false;
        }
    }

    function initMediaPipe() {
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();
    }

    // --- 3. ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() / 1000;
        const positions = mesh.geometry.attributes.position.array;
        const count = mesh.geometry.attributes.position.count;

        // Pre-calculate scale factors to avoid doing it inside the loop
        const scaleX = mesh.scale.x;
        const scaleY = mesh.scale.y;

        for (let i = 0; i < count; i++) {
            const px = positions[i * 3];
            const py = positions[i * 3 + 1];

            // Real-world position of vertex (accounting for mesh scale)
            const worldPx = px * scaleX;
            const worldPy = py * scaleY;

            // Ambient Wave
            const waveZ = Math.sin(worldPx * 0.4 + time * CONFIG.waveSpeed) * Math.cos(worldPy * 0.4 + time * CONFIG.waveSpeed) * CONFIG.waveHeight;

            // Interaction
            if (fingerPos.active) {
                const dx = worldPx - fingerPos.x;
                const dy = worldPy - fingerPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < CONFIG.brushRadius) {
                    const influence = (1 - dist / CONFIG.brushRadius);
                    elevationData[i] += influence * CONFIG.brushStrength;
                }
            }

            // Decay and Clamp
            elevationData[i] *= CONFIG.decay;
            // Apply Z
            positions[i * 3 + 2] = waveZ + elevationData[i];
        }

        mesh.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    // --- BOOTSTRAP ---
    initThree();
    initMediaPipe();
    animate();

</script>
</body>
</html>
